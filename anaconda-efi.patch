diff --git a/bootdisk/i386/grub.conf b/bootdisk/i386/grub.conf
index 156f98d..6e94d05 100644
--- a/bootdisk/i386/grub.conf
+++ b/bootdisk/i386/grub.conf
@@ -1,8 +1,8 @@
 #debug --graphics
 default=0
-splashimage=/EFI/boot/splash.xpm.gz
+splashimage=@SPLASHPATH@
 timeout 5
 hiddenmenu
 title @PRODUCT@ @VERSION@
-	kernel /EFI/boot/vmlinuz
-	initrd /EFI/boot/initrd.img
+	kernel @KERNELPATH@
+	initrd @INITRDPATH@
diff --git a/bootdisk/x86_64/grub.conf b/bootdisk/x86_64/grub.conf
index 156f98d..6e94d05 100644
--- a/bootdisk/x86_64/grub.conf
+++ b/bootdisk/x86_64/grub.conf
@@ -1,8 +1,8 @@
 #debug --graphics
 default=0
-splashimage=/EFI/boot/splash.xpm.gz
+splashimage=@SPLASHPATH@
 timeout 5
 hiddenmenu
 title @PRODUCT@ @VERSION@
-	kernel /EFI/boot/vmlinuz
-	initrd /EFI/boot/initrd.img
+	kernel @KERNELPATH@
+	initrd @INITRDPATH@
diff --git a/scripts/buildinstall b/scripts/buildinstall
index ab8d2df..f098537 100755
--- a/scripts/buildinstall
+++ b/scripts/buildinstall
@@ -219,8 +219,9 @@ echo "Writing .treeinfo file..."
 $MK_TREEINFO --family="$PRODUCTSTR" ${VARIANT:+--variant="$VARIANT"} --version=$VERSION --arch=$BASEARCH --outfile=$OUTPUT/.treeinfo
 
 # FIXME: need to update mk-images to take the yumconf
-echo "Making images..."
-$MK_IMAGES $DEBUGSTR $NOGRSTR --imgdir $TREEDIR/install --arch $BASEARCH --product "$PRODUCTSTR" --version $VERSION --bugurl "$BUGURL" --output $OUTPUT $yumconf || die "image creation failed"
+MKIMGCMD="$MK_IMAGES $DEBUGSTR $NOGRSTR --imgdir $TREEDIR/install --arch $BASEARCH --product "$PRODUCTSTR" --version $VERSION --bugurl "$BUGURL" --output $OUTPUT $yumconf"
+echo "Making images: $PWD\$ $MKIMGCMD"
+$MKIMGCMD || die "image creation failed"
 
 echo "Writing .discinfo file"
 $MK_STAMP --releasestr="$RELEASESTR" --arch=$BUILDARCH --discNum="ALL"  --outfile=$OUTPUT/.discinfo
diff --git a/scripts/mk-images b/scripts/mk-images
index d4cac46..d69301e 100755
--- a/scripts/mk-images
+++ b/scripts/mk-images
@@ -863,6 +863,7 @@ doPostImages() {
 # this gets overloaded if we're on an EFI-capable arch (... with grub)
 makeEfiImages()
 {
+    echo "Not on an EFI capable machine; skipping EFI images."
     /bin/true
 }
 
diff --git a/scripts/mk-images.efi b/scripts/mk-images.efi
index 7c25950..3be5594 100644
--- a/scripts/mk-images.efi
+++ b/scripts/mk-images.efi
@@ -45,6 +45,7 @@ makeefibootdisk()
 
 #makeefibootimage required for EFI bootloader dosfs image
 makeefibootimage() {
+    echo "in makeefibootimage: makeefibootimage $@"
     MBD_FILENAME=""
     KERNELFILE=""
     INITRDFILE=""
@@ -57,20 +58,29 @@ makeefibootimage() {
             KERNELFILE=$2
             shift; shift
             continue
+        elif [ $1 = "--kernelpath" ]; then
+            KERNELPATH=$2
+            shift; shift
+            continue
         elif [ $1 = "--initrd" ]; then
             INITRDFILE=$2
             shift; shift
             continue
+        elif [ $1 = "--initrdpath" ]; then
+            INITRDPATH=$2
+            shift; shift
+            continue
         elif [ $1 = "--imagename" ]; then
             MBD_FILENAME=$IMAGEPATH/$2
             shift; shift
             continue
         elif [ $1 = "--grubpkg" ]; then
             grubpkg=$2
+            echo "grubpkg=$grubpkg"
             shift; shift
             continue
         fi
-        echo "Unknown option passed to makebootdisk"
+        echo "Unknown option passed to makebootdisk: \"$1\""
         exit 1
     done
 
@@ -111,6 +121,7 @@ makeefibootimage() {
 
 # prepare and build an efiboot.img.
 prepareEfiImage() {
+    echo "in prepareEfiImage"
     prepareEfiTree || return 1
 
     # dynamically calculate the size of the dosfs
@@ -125,47 +136,65 @@ prepareEfiImage() {
 # prepare a directory with the kernel, initrd, and various message files
 # used to populate the efi boot image
 prepareEfiTree() {
-    mkdir -p $MBD_BOOTTREE_TMP/EFI/boot
-
-    cp -a $BOOTDISKDIR/* $MBD_BOOTTREE_TMP/EFI/boot/
-    [ -n "$INITRDFILE" ] && cp $INITRDFILE $MBD_BOOTTREE_TMP/EFI/boot/initrd.img
-    [ -n "$KERNELFILE" ] && cp $KERNELFILE $MBD_BOOTTREE_TMP/EFI/boot/vmlinuz
-
-    sed -i "s/@PRODUCT@/$PRODUCT/g" $MBD_BOOTTREE_TMP/EFI/boot/grub.conf
-    sed -i "s/@VERSION@/$VERSION/g" $MBD_BOOTTREE_TMP/EFI/boot/grub.conf
-
-    yumdownloader -c $yumconf $grubpkg
+    echo "in prepareEfiTree"
+    mkdir -p $MBD_BOOTTREE_TMP/EFI/BOOT
+
+    cp -av $BOOTDISKDIR/*.conf $MBD_BOOTTREE_TMP/EFI/BOOT/
+    [ -n "$KERNELFILE" ] && cp -av $KERNELFILE $MBD_BOOTTREE_TMP/EFI/BOOT/vmlinuz
+    [ -n "$INITRDFILE" ] && cp -av $INITRDFILE $MBD_BOOTTREE_TMP/EFI/BOOT/initrd.img
+    [ -z "$KERNELPATH" ] && KERNELPATH="/EFI/BOOT/vmlinuz"
+    [ -z "$INITRDPATH" ] && INITRDPATH="/EFI/BOOT/initrd.img"
+
+    SPLASHPATH="/EFI/BOOT/splash.xpm.gz"
+    sed -e "s/@PRODUCT@/$PRODUCT/g" \
+        -e "s/@VERSION@/$VERSION/g" \
+        -e "s,@KERNELPATH@,$KERNELPATH,g" \
+        -e "s,@INITRDPATH@,$INITRDPATH,g" \
+        -e "s,@SPLASHPATH@,$SPLASHPATH,g" \
+        -i $MBD_BOOTTREE_TMP/EFI/BOOT/grub.conf
+
+    ydcmd="yumdownloader -c $yumconf $grubpkg"
+    echo "(grubpkg) $ydcmd"
+    $ydcmd
     rpm2cpio $grubpkg.rpm | (cd $KERNELROOT; cpio --quiet -iumd)
-    cp $KERNELROOT/boot/efi/EFI/redhat/grub.efi $MBD_BOOTTREE_TMP/EFI/boot/grub.efi
+    cp -av $KERNELROOT/boot/efi/EFI/redhat/grub.efi $MBD_BOOTTREE_TMP/EFI/BOOT/grub.efi
 
     # The first generation Mactel machines get the bootloader name wrong
     # as per the spec.  Awesome, guys.
     if [ "$efiarch" == "ia32" ]; then
-        cp $MBD_BOOTTREE_TMP/EFI/boot/grub.efi $MBD_BOOTTREE_TMP/EFI/boot/boot.efi
-        cp $MBD_BOOTTREE_TMP/EFI/boot/grub.conf $MBD_BOOTTREE_TMP/EFI/boot/boot.conf
+        cp -av $MBD_BOOTTREE_TMP/EFI/BOOT/grub.efi $MBD_BOOTTREE_TMP/EFI/BOOT/BOOT.efi
+        cp -av $MBD_BOOTTREE_TMP/EFI/BOOT/grub.conf $MBD_BOOTTREE_TMP/EFI/BOOT/BOOT.conf
     fi
 
-    mv $MBD_BOOTTREE_TMP/EFI/boot/grub.efi $MBD_BOOTTREE_TMP/EFI/boot/boot${efiarch}.efi
-    mv $MBD_BOOTTREE_TMP/EFI/boot/grub.conf $MBD_BOOTTREE_TMP/EFI/boot/boot${efiarch}.conf
+    local tmpefiarch=${efiarch}
+    case ${efiarch} in
+        x64) tmpefiarch="X64" ;;
+        ia32) tmpefiarch="IA32" ;;
+    esac
+    mv -v $MBD_BOOTTREE_TMP/EFI/BOOT/grub.efi $MBD_BOOTTREE_TMP/EFI/BOOT/BOOT${tmpefiarch}.efi
+    mv -v $MBD_BOOTTREE_TMP/EFI/BOOT/grub.conf $MBD_BOOTTREE_TMP/EFI/BOOT/BOOT${tmpefiarch}.conf
 
     artpkg=$(repoquery --qf "%{NAME}-%{VERSION}-%{RELEASE}.%{ARCH}" --whatprovides ${brandpkgname}-logos | grep -v generic-logos | head -1)
     if [ -z "$artpkg" ]; then
        argpkg="generic-logos"
     fi
 
-    yumdownloader -c ${yumconf} ${artpkg}
+    ydcmd="yumdownloader -c ${yumconf} ${artpkg}"
+    echo "(artpkg) $ydcmd"
+    $ydcmd
     rpm2cpio ${artpkg}.rpm | (cd $KERNELROOT; cpio --quiet -iumd)
-    cp $KERNELROOT/boot/grub/splash.xpm.gz $MBD_BOOTTREE_TMP/EFI/boot/splash.xpm.gz
+    cp -av $KERNELROOT/boot/grub/splash.xpm.gz $MBD_BOOTTREE_TMP/$SPLASHPATH
 
     # if we don't have a kernel or initrd, we're making a CD image and we need
     # to mirror EFI/ to the cd.
     if [ -z "$KERNELFILE" -a -z "$INITRDFILE" ]; then
         cp -av $MBD_BOOTTREE_TMP/EFI/ $TOPDESTPATH/EFI/
-        rm -f $TOPDESTPATH/EFI/boot/*.efi
+        rm -f $TOPDESTPATH/EFI/BOOT/*.efi
     fi
 }
 
 makeEfiImages() {
+    echo "in makeEfiImages"
     yumconf="$1"
     echo "Making EFI images ($PWD)"
     if [ "$kernelvers" != "$kernelxen" ]; then
@@ -182,9 +211,10 @@ makeEfiImages() {
             return 1
         fi
         echo "Building efiboot.img for ${efiarch}/$KERNELARCH at $TOPDESTPATH/images/efiboot.img"
+	echo "grubpkg: ${grubpkg}"
 
         makeefibootimage \
-            --imagename pxeboot/efiboot.img \
+            --imagename efiboot.img \
             --kernel $TOPDESTPATH/images/pxeboot/vmlinuz \
             --initrd $TOPDESTPATH/images/pxeboot/initrd.img \
             --grubpkg ${grubpkg}
@@ -194,13 +224,16 @@ makeEfiImages() {
             return $ret
         fi
 
-        makeefibootdisk $TOPDESTPATH/images/pxeboot/efiboot.img $TOPDESTPATH/images/efidisk.img
-        [ $ret -eq 0 ] || return $ret
+        makeefibootdisk $TOPDESTPATH/images/efiboot.img $TOPDESTPATH/images/efidisk.img
         local ret=$?
+        [ $ret -eq 0 ] || return $ret
+        rm -vf $TOPDESTPATH/images/efiboot.img
 
         # make a boot image with just boot*.efi in it...
         makeefibootimage \
-            --imagename pxeboot/efiboot.img \
+            --imagename efiboot.img \
+            --kernelpath /images/pxeboot/vmlinuz \
+            --initrdpath /images/pxeboot/initrd.img \
             --grubpkg ${grubpkg}
         local ret=$?
         if [ $ret -ne 0 ]; then
diff --git a/scripts/mk-images.x86 b/scripts/mk-images.x86
index fe7a978..22db99c 100644
--- a/scripts/mk-images.x86
+++ b/scripts/mk-images.x86
@@ -159,15 +159,16 @@ doPostImages() {
     if [ -n "$BOOTISO" ]; then
         EFIARGS=""
         EFIGRAFT=""
-        if [ -f $TOPDESTPATH/images/pxeboot/efiboot.img ]; then
-            cp $TOPDESTPATH/images/pxeboot/efiboot.img $TOPDESTPATH/isolinux/efiboot.img
-            EFIARGS="-eltorito-alt-boot -e isolinux/efiboot.img -no-emul-boot"
-            EFIGRAFT="EFI/boot=$TOPDESTPATH/EFI/boot"
+        if [ -f $TOPDESTPATH/images/efiboot.img ]; then
+            echo "Found efiboot.img, making an EFI-capable boot.iso"
+            EFIARGS="-eltorito-alt-boot -e images/efiboot.img -no-emul-boot"
+            EFIGRAFT="EFI/BOOT=$TOPDESTPATH/EFI/BOOT"
+        else
+            echo "No efiboot.img found, making BIOS-only boot.iso"
         fi
         BIOSARGS="-b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table"
-        echo $PWD:\$ mkisofs -o $TOPDESTPATH/images/$BOOTISO $BIOSARGS $EFIARGS -R -J -V "$PRODUCT" -T -graft-points isolinux=$TOPDESTPATH/isolinux images/install.img=$TOPDESTPATH/images/install.img $EFIGRAFT
-        mkisofs -o $TOPDESTPATH/images/$BOOTISO $BIOSARGS $EFIARGS -R -J -V "$PRODUCT" -T -graft-points isolinux=$TOPDESTPATH/isolinux images/install.img=$TOPDESTPATH/images/install.img $EFIGRAFT
-        implantisomd5 $TOPDESTPATH/images/$BOOTISO
+        mkisocmd="mkisofs -v -o $TOPDESTPATH/images/$BOOTISO $BIOSARGS $EFIARGS -R -J -V "$PRODUCT" -T -graft-points isolinux=$TOPDESTPATH/isolinux images=$TOPDESTPATH/images $EFIGRAFT"
+        echo $PWD:\$ $mkisocmd
+	$mkisocmd
     fi
-
 }
