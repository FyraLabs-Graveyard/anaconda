diff -ruN anaconda-11.5.0.42.orig/bootdisk/i386/grub.conf anaconda-11.5.0.42/bootdisk/i386/grub.conf
--- anaconda-11.5.0.42.orig/bootdisk/i386/grub.conf	2009-04-09 16:53:01.000000000 -0400
+++ anaconda-11.5.0.42/bootdisk/i386/grub.conf	2009-04-09 17:00:45.000000000 -0400
@@ -1,8 +1,8 @@
 #debug --graphics
 default=0
-splashimage=/EFI/boot/splash.xpm.gz
+splashimage=@SPLASHPATH@
 timeout 5
 hiddenmenu
 title @PRODUCT@ @VERSION@
-	kernel /EFI/boot/vmlinuz
-	initrd /EFI/boot/initrd.img
+	kernel @KERNELPATH@
+	initrd @INITRDPATH@
diff -ruN anaconda-11.5.0.42.orig/bootdisk/x86_64/grub.conf anaconda-11.5.0.42/bootdisk/x86_64/grub.conf
--- anaconda-11.5.0.42.orig/bootdisk/x86_64/grub.conf	2009-04-09 16:53:01.000000000 -0400
+++ anaconda-11.5.0.42/bootdisk/x86_64/grub.conf	2009-04-09 17:00:45.000000000 -0400
@@ -1,8 +1,8 @@
 #debug --graphics
 default=0
-splashimage=/EFI/boot/splash.xpm.gz
+splashimage=@SPLASHPATH@
 timeout 5
 hiddenmenu
 title @PRODUCT@ @VERSION@
-	kernel /EFI/boot/vmlinuz
-	initrd /EFI/boot/initrd.img
+	kernel @KERNELPATH@
+	initrd @INITRDPATH@
diff -ruN anaconda-11.5.0.42.orig/scripts/buildinstall anaconda-11.5.0.42/scripts/buildinstall
--- anaconda-11.5.0.42.orig/scripts/buildinstall	2009-04-09 16:53:01.000000000 -0400
+++ anaconda-11.5.0.42/scripts/buildinstall	2009-04-09 17:00:45.000000000 -0400
@@ -219,8 +219,9 @@
 $MK_TREEINFO --family="$PRODUCTSTR" ${VARIANT:+--variant="$VARIANT"} --version=$VERSION --arch=$BASEARCH --outfile=$OUTPUT/.treeinfo
 
 # FIXME: need to update mk-images to take the yumconf
-echo "Making images..."
-$MK_IMAGES $DEBUGSTR $NOGRSTR --imgdir $TREEDIR/install --arch $BASEARCH --product "$PRODUCTSTR" --version $VERSION --bugurl "$BUGURL" --output $OUTPUT $yumconf || die "image creation failed"
+MKIMGCMD="$MK_IMAGES $DEBUGSTR $NOGRSTR --imgdir $TREEDIR/install --arch $BASEARCH --product "$PRODUCTSTR" --version $VERSION --bugurl "$BUGURL" --output $OUTPUT $yumconf"
+echo "Making images: $PWD\$ $MKIMGCMD"
+$MKIMGCMD || die "image creation failed"
 
 echo "Writing .discinfo file"
 $MK_STAMP --releasestr="$RELEASESTR" --arch=$BASEARCH --discNum="ALL"  --outfile=$OUTPUT/.discinfo
diff -ruN anaconda-11.5.0.42.orig/scripts/mk-images anaconda-11.5.0.42/scripts/mk-images
--- anaconda-11.5.0.42.orig/scripts/mk-images	2009-04-09 16:53:01.000000000 -0400
+++ anaconda-11.5.0.42/scripts/mk-images	2009-04-09 17:00:45.000000000 -0400
@@ -889,6 +889,7 @@
 # this gets overloaded if we're on an EFI-capable arch (... with grub)
 makeEfiImages()
 {
+    echo "Not on an EFI capable machine; skipping EFI images."
     /bin/true
 }
 
diff -ruN anaconda-11.5.0.42.orig/scripts/mk-images.efi anaconda-11.5.0.42/scripts/mk-images.efi
--- anaconda-11.5.0.42.orig/scripts/mk-images.efi	2009-04-09 16:53:01.000000000 -0400
+++ anaconda-11.5.0.42/scripts/mk-images.efi	2009-04-09 17:00:45.000000000 -0400
@@ -45,6 +45,7 @@
 
 #makeefibootimage required for EFI bootloader dosfs image
 makeefibootimage() {
+    echo "in makeefibootimage: makeefibootimage $@"
     MBD_FILENAME=""
     KERNELFILE=""
     INITRDFILE=""
@@ -57,20 +58,29 @@
             KERNELFILE=$2
             shift; shift
             continue
+        elif [ $1 = "--kernelpath" ]; then
+            KERNELPATH=$2
+            shift; shift
+            continue
         elif [ $1 = "--initrd" ]; then
             INITRDFILE=$2
             shift; shift
             continue
+        elif [ $1 = "--initrdpath" ]; then
+            INITRDPATH=$2
+            shift; shift
+            continue
         elif [ $1 = "--imagename" ]; then
             MBD_FILENAME=$IMAGEPATH/$2
             shift; shift
             continue
         elif [ $1 = "--grubpkg" ]; then
             grubpkg=$2
+            echo "grubpkg=$grubpkg"
             shift; shift
             continue
         fi
-        echo "Unknown option passed to makebootdisk"
+        echo "Unknown option passed to makebootdisk: \"$1\""
         exit 1
     done
 
@@ -111,6 +121,7 @@
 
 # prepare and build an efiboot.img.
 prepareEfiImage() {
+    echo "in prepareEfiImage"
     prepareEfiTree || return 1
 
     # dynamically calculate the size of the dosfs
@@ -125,47 +136,65 @@
 # prepare a directory with the kernel, initrd, and various message files
 # used to populate the efi boot image
 prepareEfiTree() {
-    mkdir -p $MBD_BOOTTREE_TMP/EFI/boot
+    echo "in prepareEfiTree"
+    mkdir -p $MBD_BOOTTREE_TMP/EFI/BOOT
 
-    cp -a $BOOTDISKDIR/* $MBD_BOOTTREE_TMP/EFI/boot/
-    [ -n "$INITRDFILE" ] && cp $INITRDFILE $MBD_BOOTTREE_TMP/EFI/boot/initrd.img
-    [ -n "$KERNELFILE" ] && cp $KERNELFILE $MBD_BOOTTREE_TMP/EFI/boot/vmlinuz
-
-    sed -i "s/@PRODUCT@/$PRODUCT/g" $MBD_BOOTTREE_TMP/EFI/boot/grub.conf
-    sed -i "s/@VERSION@/$VERSION/g" $MBD_BOOTTREE_TMP/EFI/boot/grub.conf
-
-    yumdownloader -c $yumconf $grubpkg
+    cp -av $BOOTDISKDIR/*.conf $MBD_BOOTTREE_TMP/EFI/BOOT/
+    [ -n "$KERNELFILE" ] && cp -av $KERNELFILE $MBD_BOOTTREE_TMP/EFI/BOOT/vmlinuz
+    [ -n "$INITRDFILE" ] && cp -av $INITRDFILE $MBD_BOOTTREE_TMP/EFI/BOOT/initrd.img
+    [ -z "$KERNELPATH" ] && KERNELPATH="/EFI/BOOT/vmlinuz"
+    [ -z "$INITRDPATH" ] && INITRDPATH="/EFI/BOOT/initrd.img"
+
+    SPLASHPATH="/EFI/BOOT/splash.xpm.gz"
+    sed -e "s/@PRODUCT@/$PRODUCT/g" \
+        -e "s/@VERSION@/$VERSION/g" \
+        -e "s,@KERNELPATH@,$KERNELPATH,g" \
+        -e "s,@INITRDPATH@,$INITRDPATH,g" \
+        -e "s,@SPLASHPATH@,$SPLASHPATH,g" \
+        -i $MBD_BOOTTREE_TMP/EFI/BOOT/grub.conf
+
+    ydcmd="yumdownloader -c $yumconf $grubpkg"
+    echo "(grubpkg) $ydcmd"
+    $ydcmd
     rpm2cpio $grubpkg.rpm | (cd $KERNELROOT; cpio --quiet -iumd)
-    cp $KERNELROOT/boot/efi/EFI/redhat/grub.efi $MBD_BOOTTREE_TMP/EFI/boot/grub.efi
+    cp -av $KERNELROOT/boot/efi/EFI/redhat/grub.efi $MBD_BOOTTREE_TMP/EFI/BOOT/grub.efi
 
     # The first generation Mactel machines get the bootloader name wrong
     # as per the spec.  Awesome, guys.
     if [ "$efiarch" == "ia32" ]; then
-        cp $MBD_BOOTTREE_TMP/EFI/boot/grub.efi $MBD_BOOTTREE_TMP/EFI/boot/boot.efi
-        cp $MBD_BOOTTREE_TMP/EFI/boot/grub.conf $MBD_BOOTTREE_TMP/EFI/boot/boot.conf
+        cp -av $MBD_BOOTTREE_TMP/EFI/BOOT/grub.efi $MBD_BOOTTREE_TMP/EFI/BOOT/BOOT.efi
+        cp -av $MBD_BOOTTREE_TMP/EFI/BOOT/grub.conf $MBD_BOOTTREE_TMP/EFI/BOOT/BOOT.conf
     fi
 
-    mv $MBD_BOOTTREE_TMP/EFI/boot/grub.efi $MBD_BOOTTREE_TMP/EFI/boot/boot${efiarch}.efi
-    mv $MBD_BOOTTREE_TMP/EFI/boot/grub.conf $MBD_BOOTTREE_TMP/EFI/boot/boot${efiarch}.conf
+    local tmpefiarch=${efiarch}
+    case ${efiarch} in
+        x64) tmpefiarch="X64" ;;
+        ia32) tmpefiarch="IA32" ;;
+    esac
+    mv -v $MBD_BOOTTREE_TMP/EFI/BOOT/grub.efi $MBD_BOOTTREE_TMP/EFI/BOOT/BOOT${tmpefiarch}.efi
+    mv -v $MBD_BOOTTREE_TMP/EFI/BOOT/grub.conf $MBD_BOOTTREE_TMP/EFI/BOOT/BOOT${tmpefiarch}.conf
 
     artpkg=$(repoquery --qf "%{NAME}-%{VERSION}-%{RELEASE}.%{ARCH}" --whatprovides ${brandpkgname}-logos | grep -v generic-logos | head -1)
     if [ -z "$artpkg" ]; then
        argpkg="generic-logos"
     fi
 
-    yumdownloader -c ${yumconf} ${artpkg}
+    ydcmd="yumdownloader -c ${yumconf} ${artpkg}"
+    echo "(artpkg) $ydcmd"
+    $ydcmd
     rpm2cpio ${artpkg}.rpm | (cd $KERNELROOT; cpio --quiet -iumd)
-    cp $KERNELROOT/boot/grub/splash.xpm.gz $MBD_BOOTTREE_TMP/EFI/boot/splash.xpm.gz
+    cp -av $KERNELROOT/boot/grub/splash.xpm.gz $MBD_BOOTTREE_TMP/$SPLASHPATH
 
     # if we don't have a kernel or initrd, we're making a CD image and we need
     # to mirror EFI/ to the cd.
     if [ -z "$KERNELFILE" -a -z "$INITRDFILE" ]; then
         cp -av $MBD_BOOTTREE_TMP/EFI/ $TOPDESTPATH/EFI/
-        rm -f $TOPDESTPATH/EFI/boot/*.efi
+        rm -f $TOPDESTPATH/EFI/BOOT/*.efi
     fi
 }
 
 makeEfiImages() {
+    echo "in makeEfiImages"
     yumconf="$1"
     echo "Making EFI images ($PWD)"
     if [ "$kernelvers" != "$kernelxen" ]; then
@@ -182,9 +211,10 @@
             return 1
         fi
         echo "Building efiboot.img for ${efiarch}/$KERNELARCH at $TOPDESTPATH/images/efiboot.img"
+	echo "grubpkg: ${grubpkg}"
 
         makeefibootimage \
-            --imagename pxeboot/efiboot.img \
+            --imagename efiboot.img \
             --kernel $TOPDESTPATH/images/pxeboot/vmlinuz \
             --initrd $TOPDESTPATH/images/pxeboot/initrd.img \
             --grubpkg ${grubpkg}
@@ -194,13 +224,16 @@
             return $ret
         fi
 
-        makeefibootdisk $TOPDESTPATH/images/pxeboot/efiboot.img $TOPDESTPATH/images/efidisk.img
-        [ $ret -eq 0 ] || return $ret
+        makeefibootdisk $TOPDESTPATH/images/efiboot.img $TOPDESTPATH/images/efidisk.img
         local ret=$?
+        [ $ret -eq 0 ] || return $ret
+        rm -vf $TOPDESTPATH/images/efiboot.img
 
         # make a boot image with just boot*.efi in it...
         makeefibootimage \
-            --imagename pxeboot/efiboot.img \
+            --imagename efiboot.img \
+            --kernelpath /images/pxeboot/vmlinuz \
+            --initrdpath /images/pxeboot/initrd.img \
             --grubpkg ${grubpkg}
         local ret=$?
         if [ $ret -ne 0 ]; then
diff -ruN anaconda-11.5.0.42.orig/scripts/mk-images.orig anaconda-11.5.0.42/scripts/mk-images.orig
--- anaconda-11.5.0.42.orig/scripts/mk-images.orig	1969-12-31 19:00:00.000000000 -0500
+++ anaconda-11.5.0.42/scripts/mk-images.orig	2009-04-09 16:53:01.000000000 -0400
@@ -0,0 +1,1003 @@
+#!/bin/bash
+#
+# mk-images
+#
+# Copyright (C) 2007  Red Hat, Inc.  All rights reserved.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+#
+
+LANG=C
+
+PATH=$PATH:/sbin:/usr/sbin
+IMAGEUUID=$(date +%Y%m%d%H%M).$(uname -i)
+TMPDIR=${TMPDIR:-/tmp}
+
+usage () {
+    echo "usage: mk-images <pkgsrc> <toplevel> <template> <imgdir> <buildarch> <productname> <version> [<productpath>]"
+    exit 0
+}
+
+DEBUG=""
+BUILDARCH=`uname -m`
+BOOTISO="boot.iso"
+
+while [ $# -gt 0 ]; do
+    case $1 in
+        --debug)
+            DEBUG="--debug"
+            shift
+        ;;
+        --noiso)
+            BOOTISO=""
+            shift
+        ;;
+        --arch)
+            BUILDARCH=$2
+            shift; shift
+        ;;
+        --imgdir)
+            IMGPATH=$2
+            shift; shift
+        ;;
+        --product)
+            PRODUCT=$2
+            shift; shift
+        ;;
+        --version)
+            VERSION=$2
+            shift; shift
+        ;;
+        --bugurl)
+            BUGURL=$2
+            shift; shift
+        ;;
+        --output)
+            TOPDESTPATH=$2
+            shift; shift
+        ;;
+        --nogr)
+            echo "*** DeprecationWarning: ignoring --nogr option." >&2
+            shift
+        ;;
+        --mindir)
+            echo "*** DeprecationWarning: ignoring --mindir option." >&2
+            shift; shift
+        ;;
+        --stg2dir)
+            echo "*** DeprecationWarning: please use --imgdir instead of --stg2dir." >&2
+            shift; shift
+        ;;
+        *)
+            yumconf=$1
+            shift
+        ;;
+    esac
+done
+
+if [ -z "$TOPDESTPATH" -o -z "$IMGPATH" -o -z "$PRODUCT" -o -z "$VERSION" ]; then usage; fi
+
+TOPDIR=$(echo $0 | sed "s,/[^/]*$,,")
+if [ $TOPDIR = $0 ]; then
+    $TOPDIR="."
+fi
+TOPDIR=$(cd $TOPDIR; pwd)
+
+# modules that are needed.  this is the generic "needed for every arch" stuff
+COMMONMODS="fat vfat nfs sunrpc lockd floppy cramfs loop edd pcspkr squashfs ipv6 virtio_pci"
+USBMODS="ohci-hcd uhci-hcd ehci-hcd usbhid mousedev usb-storage sd_mod sr_mod ub appletouch"
+FIREWIREMODS="ohci1394 sbp2 fw-ohci fw-sbp2 firewire-sbp2 firewire-ohci"
+SDMODS="mmc-block sdhci sdhci-pci"
+IDEMODS="ide-cd ide-cd_mod"
+SCSIMODS="sr_mod sg st sd_mod scsi_mod iscsi_tcp iscsi_ibft"
+FSMODS="fat msdos vfat ext2 ext3 ext4 reiserfs jfs xfs gfs2 cifs fuse btrfs"
+LVMMODS="dm-mod dm-zero dm-snapshot dm-mirror dm-multipath dm-round-robin dm-crypt"
+RAIDMODS="raid0 raid1 raid5 raid6 raid456 raid10 linear"
+CRYPTOMODS="sha256_generic cbc xts lrw aes_generic crypto_blkcipher crc32c ecb arc4"
+PCMCIASOCKMODS="yenta_socket i82365 tcic pcmcia"
+INITRDMODS="$USBMODS $FIREWIREMODS $IDEMODS $SCSIMODS $FSMODS $LVMMODS $RAIDMODS $CRYPTOMODS $COMMONMODS $PCMCIASOCKMODS $SDMODS =scsi =net =drm"
+
+. $(dirname $0)/buildinstall.functions
+
+# Set, verify, and create paths
+IMAGEPATH=$TOPDESTPATH/images
+FULLMODPATH=$TMPDIR/instimagemods.$$
+FINALFULLMODPATH=$IMGPATH/modules
+INSTIMGPATH=$TOPDESTPATH/images
+KERNELBASE=$TMPDIR/updboot.kernel.$$
+
+KERNELNAME=vmlinuz
+if [ "$BUILDARCH" = "ia64" ]; then
+    KERNELDIR="/boot/efi/EFI/redhat"
+else
+    KERNELDIR="/boot"
+fi
+
+if [ "$BUILDARCH" = "sparc64" ]; then
+    BASEARCH=sparc
+else
+    BASEARCH=$BUILDARCH
+fi
+
+# explicit block size setting for some arches (FIXME: we compose
+# ppc64-ish trees as ppc, so we have to set the "wrong" block size)
+if [ "$BUILDARCH" = "sparc64" ]; then
+    CRAMBS="--blocksize 8192"
+elif [ "$BUILDARCH" = "sparc" ]; then
+    CRAMBS="--blocksize 4096"
+else
+    CRAMBS=""
+fi
+
+if [ $BUILDARCH = x86_64 -o $BUILDARCH = s390x ]; then
+    LIBDIR=lib64
+else
+    LIBDIR=lib
+fi
+
+rm -rf $IMAGEPATH
+rm -rf $FULLMODPATH
+rm -rf $FINALFULLMODPATH
+rm -rf $KERNELBASE
+mkdir -p $IMAGEPATH
+mkdir -p $FULLMODPATH
+mkdir -p $FINALFULLMODPATH
+mkdir -p $KERNELBASE
+mkdir -p $INSTIMGPATH
+
+# Stuff that we need
+TRIMPCIIDS=$IMGPATH/usr/lib/anaconda-runtime/trimpciids
+GETKEYMAPS=$IMGPATH/usr/lib/anaconda-runtime/getkeymaps
+GENINITRDSZ=$IMGPATH/usr/lib/anaconda-runtime/geninitrdsz
+MKS390CDBOOT=$IMGPATH/usr/lib/anaconda-runtime/mk-s390-cdboot
+GENMODINFO=$IMGPATH/usr/lib/anaconda-runtime/genmodinfo
+KEYMAPS=$TMPDIR/keymaps-$BUILDARCH.$$
+SCREENFONT=$IMGPATH/usr/lib/anaconda-runtime/screenfont-${BASEARCH}.gz
+MODLIST=$IMGPATH/usr/lib/anaconda-runtime/modlist
+MODINFO=$TMPDIR/modinfo-$BUILDARCH.$$
+LOADERBINDIR=$IMGPATH/usr/lib/anaconda-runtime/loader
+BOOTDISKDIR=$IMGPATH/usr/lib/anaconda-runtime/boot
+LANGTABLE=$IMGPATH/usr/lib/anaconda/lang-table
+PCIIDS=$IMGPATH/usr/share/hwdata/pci.ids
+XDRIVERS=$IMGPATH/usr/share/hwdata/videoaliases
+XDRIVERDESCS=$IMGPATH/usr/share/hwdata/videodrivers
+
+REQUIREMENTS="$TRIMPCIIDS $PCIIDS $XDRIVERDESCS $GENMODINFO
+      $LANGTABLE $GETKEYMAPS"
+
+dieLater=
+for n in $REQUIREMENTS; do
+    if [ ! -f $n ]; then
+        echo "$n doesn't exist"
+        dieLater=1
+    fi
+done
+
+for n in $BOOTDISKDIR; do
+    if [ ! -d $n ]; then
+        echo "$n doesn't exist"
+        dieLater=1
+    fi
+done
+
+if [ -n "$dieLater" ]; then exit 1; fi
+
+if [ "$BUILDARCH" != "s390" -a "$BUILDARCH" != "s390x" ]; then
+    # go ahead and create the keymaps so we only have to do it once
+    if [ -f $IMGPATH/usr/lib/anaconda-runtime/keymaps-override-$BUILDARCH ]; then
+        echo "Found keymap override, using it"
+        cp $IMGPATH/usr/lib/anaconda-runtime/keymaps-override-$BUILDARCH $KEYMAPS
+    else
+        echo "Running: $GETKEYMAPS $BUILDARCH $KEYMAPS $IMGPATH"
+        $GETKEYMAPS $BUILDARCH $KEYMAPS $IMGPATH
+        if [ $? != 0 ]; then
+            echo "Unable to create keymaps and thus can't create initrd."
+            exit 1
+        fi
+    fi
+fi
+
+findPackage() {
+    name=$1
+
+    pkg=$(repoquery --qf "%{NAME}-%{VERSION}-%{RELEASE}.%{ARCH}" -c $yumconf --archlist=$KERNELARCH $name.$KERNELARCH)
+    if [ -n "$pkg" ]; then
+        echo $pkg
+        return
+    fi
+    echo "cannot find package $name" >&2
+}
+
+rundepmod () {
+    where=$1
+
+    $FAKEARCH /sbin/depmod -a -F $KERNELROOT/boot/System.map-$version \
+            -b $where $version
+}
+
+# This loops to make sure it resolves dependencies of dependencies of...
+resdeps () {
+    items="$*"
+
+    deplist=""
+    for item in $items ; do
+        deps=$(awk -F ':' "/$item.ko: / { print gensub(\".*/$item.ko: \",\"\",\"g\") }" $KERNELROOT/lib/modules/$version/modules.dep)
+        for dep in $deps ; do
+            depfile=${dep##*/}
+            depname=${dep%%.ko}
+            deplist="$deplist $depname"
+        done
+    done
+    items=$(for n in $items $deplist; do echo $n; done | sort -u)
+    echo $items
+}
+
+expandModuleSet() {
+    SET=""
+    for name in $1; do
+        char=$(echo $name | cut -c1)
+        if [ $char = '=' ]; then
+	    NAME=$(echo $name | cut -c2-)
+	    if [ "$NAME" = "ata" ]; then
+		SET="$SET $(egrep '(ata|ahci)' $KERNELROOT/lib/modules/$version/modules.block |sed -e 's/.ko//')"
+	    elif [ "$NAME" = "scsi" ]; then
+		SET="$SET $(sed -e 's/.ko//' $KERNELROOT/lib/modules/$version/modules.block)"
+	    elif [ "$NAME" = "net" ]; then
+		SET="$SET $(sed -e 's/.ko//' $KERNELROOT/lib/modules/$version/modules.networking)"
+	    else
+                # Ignore if group list does not exist
+                if [ -e $KERNELROOT/lib/modules/$version/modules.$NAME ]; then
+		    SET="$SET $(sed -e 's/.ko//' $KERNELROOT/lib/modules/$version/modules.$NAME)"
+                fi
+            fi
+        else
+            SET="$SET $name"
+        fi
+    done
+
+    echo $SET
+}
+
+makemoduletree() {
+    MMB_DIR=$1
+    MMB_MODULESET=$(resdeps $2)
+
+    mkdir -p $MMB_DIR/lib
+    mkdir -p $MMB_DIR/modules
+    mkdir -p $MMB_DIR/firmware
+    ln -snf ../modules $MMB_DIR/lib/modules
+    ln -snf ../firmware $MMB_DIR/lib/firmware
+
+    echo "Copying kernel modules..."
+    cp -a $KERNELROOT/lib/modules/* $MMB_DIR/lib/modules/
+    echo "Removing extraneous modules..."
+    find $MMB_DIR/lib/modules/ -name *.ko | while read module ; do
+        m=${module##*/}
+        modname=${m%%.ko}
+        echo $MMB_MODULESET | grep -wq $modname || {
+            rm -f $module
+        }
+    done
+
+    echo "Copying required firmware..."
+    find $MMB_DIR/lib/modules/ -name *.ko | while read module ; do
+        for fw in $(modinfo -F firmware $module); do
+            dest=$MBD_DIR/firmware/$fw
+            destdir=$(dirname $dest)
+
+            # Some firmware files are expected to be in their own directories.
+            if [ ! -d $destdir ]; then
+                mkdir -p $destdir
+            fi
+
+            cp $KERNELROOT/lib/firmware/$fw $dest
+        done
+    done
+
+    # Copy in driver firmware we know we'll want during installation. This is
+    # required for modules which still don't (or can't) export information
+    # about what firmware files they require.
+    for module in $MODSET ; do
+        case $module in
+            ipw2100)
+                cp $KERNELROOT/lib/firmware/ipw2100* $MBD_DIR/firmware
+            ;;
+            ipw2200)
+                cp $KERNELROOT/lib/firmware/ipw2200* $MBD_DIR/firmware
+            ;;
+            iwl3945)
+                cp $KERNELROOT/lib/firmware/iwlwifi-3945* $MBD_DIR/firmware
+            ;;
+            atmel)
+                cp $KERNELROOT/lib/firmware/atmel_*.bin $MBD_DIR/firmware
+            ;;
+            zd1211rw)
+                cp -r $KERNELROOT/lib/firmware/zd1211 $MBD_DIR/firmware
+            ;;
+        esac
+    done
+
+    # clean up leftover cruft
+    find -H $MMB_DIR/lib/modules -type d -exec rmdir -f {} \; 2>/dev/null
+    $MODLIST --modinfo-file $MODINFO --ignore-missing --modinfo \
+    $MMB_MODULESET > $MMB_DIR/lib/modules/module-info
+    # compress modules
+    find -H $MMB_DIR/lib/modules -type f -name *.ko -exec gzip -9 {} \;
+    rundepmod $MMB_DIR
+    rm -f $MMB_DIR/lib/modules/*/modules.*map
+    rm -f $MMB_DIR/lib/modules/*/{build,source}
+
+    # create the pci.ids, from modules.alias and the X driver aliases
+    awk '!/^(\t\t|#)/ { print ;if ($0 == "ffff  Illegal Vendor ID") nextfile; }' < $PCIIDS | \
+        $TRIMPCIIDS $MMB_DIR/lib/modules/*/modules.alias $XDRIVERS/* > ../pci.ids
+}
+
+
+makeproductfile() {
+    root=$1
+
+    rm -f $root/.buildstamp
+    echo $IMAGEUUID > $root/.buildstamp
+    echo $PRODUCT >> $root/.buildstamp
+    echo $VERSION >> $root/.buildstamp
+    if [ -n "$BUGURL" ]; then
+        echo $BUGURL >> $root/.buildstamp
+    fi
+}
+
+instbin() {
+    ROOT=$1
+    BIN=$2
+    DIR=$3
+    DEST=$4
+
+    iself="$(file $ROOT/$BIN | grep ELF | grep executable)"
+
+    if [ -l $ROOT/$BIN ]; then
+        cp -a $ROOT/$BIN $DIR/$DEST
+    else
+        if [ -z "$iself" ]; then
+            install -m 755 $ROOT/$BIN $DIR/$DEST
+        else
+            install -s -m 755 $ROOT/$BIN $DIR/$DEST
+
+            get_dso_deps $ROOT "$BIN"
+            local DEPS="$DSO_DEPS"
+            mkdir -p $DIR/$LIBDIR
+
+            for x in $DEPS ; do
+                cp -Lfp $ROOT/$x $DIR/$LIBDIR
+            done
+
+            pushd $DIR/$LIBDIR
+            if [ -f ld-linux.so.2 -a ! -L ld-linux.so.2 ]; then
+                rm -f ld-linux.so.2
+                linker="$(ls -1 ld-*.*.*.so)"
+                if [ -z "$linker" ]; then
+                    linker="$(ls -1 ld-*.*.so)"
+                fi
+                found=$(echo $linker | wc -l)
+                if [ $found -ne 1 ]; then
+                    echo "Found too many dynamic linkers:" >&2
+                    echo $linker >&2
+                    exit 1
+                fi
+                ln -s $linker ld-linux.so.2
+            fi
+            popd
+        fi
+    fi
+}
+
+setupShellEnvironment() {
+    echo "tcp     6       TCP" > $MBD_DIR/etc/protocols
+
+    # PAM configuration
+    for i in pam_limits.so pam_env.so pam_unix.so pam_deny.so; do
+        cp -f $IMGPATH/$LIBDIR/security/$i $MBD_DIR/$LIBDIR/security
+    done
+
+    cp -f $IMGPATH/etc/pam.d/other $MBD_DIR/etc/pam.d
+    cat > $MBD_DIR/etc/pam.d/login << EOF
+#%PAM-1.0
+auth        required      pam_env.so
+auth        sufficient    pam_unix.so likeauth nullok
+auth        required      pam_deny.so
+account     required      pam_unix.so
+password    sufficient    pam_unix.so nullok use_authtok md5 shadow
+password    required      pam_deny.so
+session     required      pam_limits.so
+session     required      pam_unix.so
+EOF
+    cp -f $MBD_DIR/etc/pam.d/login $MBD_DIR/etc/pam.d/sshd
+    cp -f $MBD_DIR/etc/pam.d/login $MBD_DIR/etc/pam.d/remote
+
+    cp -f $IMGPATH/etc/security/{limits.conf,pam_env.conf} $MBD_DIR/etc/security/
+
+    # key generation takes ages on s390, you really don't want this for every
+    # installation attempt. These are NOT the keys of the installed system!
+    mkdir -m 0700 -p $MBD_DIR/etc/ssh
+    echo -n "Generating SSH1 RSA host key: "
+    /usr/bin/ssh-keygen -q -t rsa1 -f $MBD_DIR/etc/ssh/ssh_host_key \
+                        -C '' -N '' >&/dev/null
+    echo
+    echo -n "Generating SSH2 RSA host key: "
+    /usr/bin/ssh-keygen -q -t rsa -f $MBD_DIR/etc/ssh/ssh_host_rsa_key \
+                        -C '' -N '' >&/dev/null
+    echo
+    echo -n "Generating SSH2 DSA host key: "
+    /usr/bin/ssh-keygen -q -t dsa -f $MBD_DIR/etc/ssh/ssh_host_dsa_key \
+                        -C '' -N '' >&/dev/null
+    echo
+    (cd $MBD_DIR/etc/ssh; \
+        chmod 600 ssh_host_key ssh_host_rsa_key ssh_host_dsa_key; \
+        chmod 644 ssh_host_key.pub ssh_host_rsa_key.pub ssh_host_dsa_key.pub; )
+
+    cat > $MBD_DIR/etc/ssh/sshd_config <<EOF
+Port 22
+HostKey /etc/ssh/ssh_host_key
+HostKey /etc/ssh/ssh_host_rsa_key
+HostKey /etc/ssh/ssh_host_dsa_key
+PermitRootLogin yes
+IgnoreRhosts yes
+StrictModes yes
+X11Forwarding yes
+X11DisplayOffset 10
+PrintMotd yes
+XAuthLocation /sbin/xauth
+KeepAlive yes
+SyslogFacility AUTHPRIV
+RSAAuthentication yes
+PasswordAuthentication yes
+PermitEmptyPasswords yes
+PermitUserEnvironment yes
+EOF
+    chmod 600 $MBD_DIR/etc/ssh/sshd_config
+
+    # copy in the binaries
+    instbin $IMGPATH /usr/bin/login $MBD_DIR /sbin/login
+    instbin $IMGPATH /usr/sbin/sshd $MBD_DIR /sbin/sshd
+    instbin $IMGPATH /usr/bin/busybox $MBD_DIR /sbin/busybox
+
+    # make some symlinks
+    (cd $MBD_DIR/sbin;
+        set $(./busybox 2>&1| awk '/^\t([[:alnum:]_\.\[]+,)+/' | sed 's/,//g' | sed 's/ +//');
+        while [ -n "$1" ]; do
+              if [ $1 != "busybox" -a $1 != "sh" ]; then
+                # if file doesnt already exist, link to busybox
+                if [ ! -f "$1" ]; then
+                    ln -sf ./busybox $1
+                else
+                    [ -n "$DEBUG" ] && echo "Overriding busybox version of $1"
+                fi
+            fi
+            shift
+        done )
+}
+
+
+makeinitrd() {
+    EXTRAINITRDPATH=""
+    INITRDSIZE=""
+    KEEP=""
+    PADSIZE=""
+    LOADERBIN=""
+    INITRDMODULES=""
+    MYLANGTABLE=$LANGTABLE
+    MYLOADERTR=loader.tr
+    while [ x$(echo $1 | cut -c1-2) = x"--" ]; do
+        if [ $1 = "--initrdto" ]; then
+            EXTRAINITRDPATH=$2
+            shift; shift
+            continue
+        elif [ $1 = "--keep" ]; then
+            KEEP=yes
+            shift
+            continue
+        elif [ $1 = "--initrdsize" ]; then
+            INITRDSIZE=$2
+            shift; shift
+            continue
+        elif [ $1 = "--loaderbin" ]; then
+            LOADERBIN=$2
+            shift; shift
+            continue
+        elif [ $1 = "--modules" ]; then
+            INITRDMODULES=$2
+            shift; shift
+            continue
+        fi
+        echo "Unknown option passed to makeinitrd"
+        exit 1
+    done
+    if [ -z "$LOADERBIN" ]; then
+        echo "no loader binary specified!" >&2
+        exit 1
+    fi
+    if [ -z "$INITRDMODULES" ]; then
+        echo "warning: no loader modules specified!" >&2
+    fi
+    if [ -z "$INITRDSIZE" ]; then
+        echo "I don't know how big to make the initrd image!" >&2
+        exit 1
+    fi
+
+    MBD_DIR=$TMPDIR/makebootdisk.dir.$$
+    MBD_FSIMAGE=$TMPDIR/makebootdisk.initrdimage.$$
+    MBD_BOOTTREE=$TMPDIR/makebootdisk.tree.$$
+
+    rm -rf $MBD_DIR $MBD_FSIMAGE
+    mkdir -p $MBD_DIR/modules
+    mkdir -p $MBD_DIR/sbin
+    mkdir -p $MBD_DIR/dev
+    mkdir -p $MBD_DIR/etc
+    mkdir -p $MBD_DIR/etc/udev/rules.d
+    mkdir -p $MBD_DIR/lib/udev/rules.d
+    mkdir -p $MBD_DIR/proc
+    mkdir -p $MBD_DIR/selinux
+    mkdir -p $MBD_DIR/sys
+    mkdir -p $MBD_DIR/etc/terminfo/{a,b,d,l,s,v,x}
+    mkdir -p $MBD_DIR/tmp
+    mkdir -p $MBD_DIR/usr/libexec
+    mkdir -p $MBD_DIR/usr/$LIBDIR/NetworkManager
+    mkdir -p $MBD_DIR/usr/share/dbus-1/system-services
+    mkdir -p $MBD_DIR/var/cache/hald
+    mkdir -p $MBD_DIR/var/lib/dbus
+    mkdir -p $MBD_DIR/var/lib/dhclient
+    mkdir -p $MBD_DIR/var/lock/rpm
+    mkdir -p $MBD_DIR/var/run
+    mkdir -p $MBD_DIR/var/run/dbus
+    mkdir -p $MBD_DIR/var/run/hald
+    mkdir -p $MBD_DIR/var/run/NetworkManager
+    mkdir -p $MBD_DIR/etc/dbus-1/system.d
+    mkdir -p $MBD_DIR/etc/modprobe.d
+    mkdir -p $MBD_DIR/etc/NetworkManager/dispatcher.d
+    mkdir -p $MBD_DIR/$LIBDIR/dbus-1
+    mkdir -p $MBD_DIR/etc/sysconfig/network-scripts
+    mkdir -p $MBD_DIR/usr/share/PolicyKit/policy
+    mkdir -p $MBD_DIR/etc/PolicyKit
+    mkdir -p $MBD_DIR/var/lib/misc
+    mkdir -p $MBD_DIR/etc/hal/fdi
+    mkdir -p $MBD_DIR/usr/share/hal/fdi
+    mkdir -p $MBD_DIR/usr/share/hwdata
+    mkdir -p $MBD_DIR/etc/rc.d/init.d
+    mkdir -p $MBD_DIR/usr/sbin
+    mkdir -p $MBD_DIR/var/run/wpa_supplicant
+
+    if [ "$BUILDARCH" = "s390" -o "$BUILDARCH" = "s390x" ]; then
+        mkdir -m 111 -p $MBD_DIR/var/empty/sshd
+        mkdir -p $MBD_DIR/etc/{pam.d,security}
+        mkdir -p $MBD_DIR/$LIBDIR/security
+        cp $IMGPATH/$LIBDIR/libpam_misc.so.0.* $MBD_DIR/$LIBDIR/libpam_misc.so.0
+        ln -s /tmp $MBD_DIR/var/state/xkb
+        cp $IMGPATH/usr/bin/xauth $MBD_DIR/sbin/xauth
+        cp $IMGPATH/usr/sbin/cmsfs* $MBD_DIR/sbin/
+    fi
+
+    if [ -n "$INITRDMODULES" ]; then
+        MODSET=`expandModuleSet "$INITRDMODULES"`
+        makemoduletree $MBD_DIR "$MODSET"
+    fi
+
+    # set up the arch bits
+    echo $arch > $MBD_DIR/etc/arch
+
+    echo "Setting up arch bits"
+    instbin $IMGPATH ${LOADERBINDIR##$IMGPATH}/$LOADERBIN $MBD_DIR /sbin/loader
+    if [ "$BUILDARCH" != "s390" -a "$BUILDARCH" != "s390x" ]; then
+        instbin $IMGPATH ${LOADERBINDIR##$IMGPATH}/init $MBD_DIR /sbin/init
+        ln -s ./init $MBD_DIR/sbin/reboot
+        ln -s ./init $MBD_DIR/sbin/halt
+        ln -s ./init $MBD_DIR/sbin/poweroff
+    else
+        instbin $IMGPATH ${LOADERBINDIR##IMGPATH}/shutdown $MBD_DIR /sbin/shutdown
+        instbin $IMGPATH /usr/lib/anaconda-runtime/loader/linuxrc.s390 $MBD_DIR /sbin/init
+        instbin $IMGPATH /usr/sbin/dasdfmt $MBD_DIR /sbin/dasdfmt
+    fi
+
+    if [ "$BUILDARCH" != "s390" -a "$BUILDARCH" != "s390x" ]; then
+       install -m 644 $KEYMAPS $MBD_DIR/etc/keymaps.gz
+       install -m 644 $SCREENFONT $MBD_DIR/etc/screenfont.gz
+    fi
+
+    install -m 644 $MYLANGTABLE $MBD_DIR/etc/lang-table
+    install -m 644 $IMGPATH/etc/passwd $MBD_DIR/etc/passwd
+    install -m 644 $IMGPATH/etc/group $MBD_DIR/etc/group
+    install -m 644 $IMGPATH/etc/nsswitch.conf $MBD_DIR/etc/nsswitch.conf
+    install -m 644 $IMGPATH/etc/hosts $MBD_DIR/etc/hosts
+
+    instbin $IMGPATH /usr/bin/mount $MBD_DIR /sbin/mount
+    for mountcmd in $IMGPATH/usr/sbin/mount.* ; do
+        cmd="$(basename $mountcmd)"
+        instbin $IMGPATH /usr/sbin/$cmd $MBD_DIR /sbin/$cmd
+    done
+    instbin $IMGPATH /usr/bin/umount $MBD_DIR /sbin/umount
+    for umountcmd in $IMGPATH/usr/sbin/umount.* ; do
+        cmd="$(basename $umountcmd)"
+        instbin $IMGPATH /usr/sbin/$cmd $MBD_DIR /sbin/$cmd
+    done
+
+    instbin $IMGPATH /usr/sbin/udevd $MBD_DIR /sbin/udevd
+    instbin $IMGPATH /usr/sbin/udevadm $MBD_DIR /sbin/udevadm
+    instbin $IMGPATH /usr/bin/udevinfo $MBD_DIR /sbin/udevinfo
+
+    instbin $IMGPATH /usr/bin/bash $MBD_DIR /sbin/bash
+    ( cd $MBD_DIR/sbin ; ln -sf bash sh )
+    instbin $IMGPATH /usr/sbin/consoletype $MBD_DIR /sbin/consoletype
+    instbin $IMGPATH /usr/bin/logger $MBD_DIR /sbin/logger
+
+    ( cd $IMGPATH/etc/rc.d/init.d
+      cp -a functions $MBD_DIR/etc/rc.d/init.d
+    )
+
+    ( cd $IMGPATH/etc/sysconfig/network-scripts
+      cp -a network-functions $MBD_DIR/etc/sysconfig/network-scripts
+      cp -a network-functions-ipv6 $MBD_DIR/etc/sysconfig/network-scripts
+    )
+
+    ( cd $MBD_DIR/etc ; ln -sf /etc/rc.d/init.d init.d )
+
+    # DHCP and DHCPv6 client daemons and support programs
+    instbin $IMGPATH /usr/sbin/dhclient $MBD_DIR /sbin/dhclient
+    cp -a $IMGPATH/usr/sbin/dhclient-script $MBD_DIR/sbin/dhclient-script
+    chmod 0755 $MBD_DIR/sbin/dhclient-script
+    instbin $IMGPATH /usr/sbin/dhcp6c $MBD_DIR /sbin/dhcp6c
+    instbin $IMGPATH /usr/sbin/arping $MBD_DIR /sbin/arping
+    instbin $IMGPATH /usr/sbin/ifconfig $MBD_DIR /sbin/ifconfig
+    instbin $IMGPATH /usr/sbin/ip $MBD_DIR /sbin/ip
+    touch $MBD_DIR/etc/resolv.conf
+
+    # hwdata
+    cp -a $IMGPATH/usr/share/hwdata/pci.ids $MBD_DIR/usr/share/hwdata/pci.ids
+    cp -a $IMGPATH/usr/share/hwdata/usb.ids $MBD_DIR/usr/share/hwdata/usb.ids
+
+    # hal
+    instbin $IMGPATH /usr/sbin/hald $MBD_DIR /sbin/hald
+    ( cd $IMGPATH/usr/libexec
+      for f in hald-runner hald-generate-fdi-cache hal*storage* ; do
+          instbin $IMGPATH /usr/libexec/$f $MBD_DIR /usr/libexec/$f
+      done
+    )
+    touch $MBD_DIR/var/run/hald.acl-list
+    cp -a $IMGPATH/usr/share/hal/fdi/* $MBD_DIR/usr/share/hal/fdi
+    cp -a $IMGPATH/etc/hal/fdi/* $MBD_DIR/etc/hal/fdi
+    cp -a $IMGPATH/etc/dbus-1/system.d/hal.conf $MBD_DIR/etc/dbus-1/system.d
+
+    # PolicyKit
+    ( cd $IMGPATH/etc/PolicyKit
+      cp -a PolicyKit.conf $MBD_DIR/etc/PolicyKit
+    )
+    ( cd $IMGPATH/usr/share/dbus-1/system-services
+      cp -a org.freedesktop.PolicyKit.service $MBD_DIR/usr/share/dbus-1/system-services
+    )
+    ( cd $IMGPATH/usr/share/PolicyKit/policy
+      cp -a org.freedesktop.policykit.policy $MBD_DIR/usr/share/PolicyKit/policy
+    )
+    ( cd $IMGPATH/var/lib/misc
+      cp -a PolicyKit.reload $MBD_DIR/var/lib/misc
+    )
+
+    # dbus
+    instbin $IMGPATH /usr/bin/dbus-uuidgen $MBD_DIR /sbin/dbus-uuidgen
+    instbin $IMGPATH /usr/bin/dbus-daemon $MBD_DIR /sbin/dbus-daemon
+    cp -a $IMGPATH/etc/dbus-1/system.conf $MBD_DIR/etc/dbus-1/system.conf
+    cp -a $IMGPATH/$LIBDIR/dbus-1/dbus-daemon-launch-helper $MBD_DIR/$LIBDIR/dbus-1
+    chown root:dbus $MBD_DIR/$LIBDIR/dbus-1/dbus-daemon-launch-helper
+    chmod 04750 $MBD_DIR/$LIBDIR/dbus-1/dbus-daemon-launch-helper
+
+    # wpa_supplicant
+    instbin $IMGPATH /usr/sbin/wpa_passphrase $MBD_DIR /usr/sbin/wpa_passphrase
+    instbin $IMGPATH /usr/sbin/wpa_supplicant $MBD_DIR /usr/sbin/wpa_supplicant
+    cp -a $IMGPATH/etc/dbus-1/system.d/wpa_supplicant.conf $MBD_DIR/etc/dbus-1/system.d
+    cp -a $IMGPATH/etc/wpa_supplicant/wpa_supplicant.conf $MBD_DIR/etc/wpa_supplicant
+    ( cd $IMGPATH/usr/share/dbus-1/system-services
+      cp -a fi.epitest.hostap.WPASupplicant.service $MBD_DIR/usr/share/dbus-1/system-services
+    )
+
+    # NetworkManager
+    instbin $IMGPATH /usr/sbin/NetworkManager $MBD_DIR /usr/sbin/NetworkManager
+    instbin $IMGPATH /usr/sbin/nm-system-settings $MBD_DIR /usr/sbin/nm-system-settings
+    cp -a $IMGPATH/etc/dbus-1/system.d/nm-*.conf $MBD_DIR/etc/dbus-1/system.d
+    cp -a $IMGPATH/etc/dbus-1/system.d/NetworkManager.conf $MBD_DIR/etc/dbus-1/system.d
+    cp -a $IMGPATH/etc/NetworkManager/nm-system-settings.conf $MBD_DIR/etc/NetworkManager
+    ( cd $IMGPATH/usr/$LIBDIR/NetworkManager
+      for f in *.so ; do
+          instbin $IMGPATH /usr/$LIBDIR/NetworkManager/$f $MBD_DIR /usr/$LIBDIR/NetworkManager/$f
+      done
+    )
+    ( cd $IMGPATH/usr/libexec
+      for f in nm-* ; do
+          instbin $IMGPATH /usr/libexec/$f $MBD_DIR /usr/libexec/$f
+      done
+    )
+    ( cd $IMGPATH/usr/share/dbus-1/system-services
+      cp -a org.freedesktop.NetworkManagerSystemSettings.service $MBD_DIR/usr/share/dbus-1/system-services
+      cp -a org.freedesktop.nm_dispatcher.service $MBD_DIR/usr/share/dbus-1/system-services
+    )
+
+    # Indirect dependencies
+    install -m 755 $IMGPATH/$LIBDIR/libfreebl3.so $MBD_DIR/$LIBDIR/
+    install -m 755 $IMGPATH/$LIBDIR/libsoftokn3.so $MBD_DIR/$LIBDIR/
+    install -m 755 $IMGPATH/usr/$LIBDIR/libsqlite3.so.0 $MBD_DIR/usr/$LIBDIR/
+    install -m 755 $IMGPATH/$LIBDIR/libnss_dns.so.2 $MBD_DIR/$LIBDIR/
+    install -m 755 $IMGPATH/$LIBDIR/libnss_files.so.2 $MBD_DIR/$LIBDIR/
+    install -m 755 $IMGPATH/$LIBDIR/libgcc_s.so.1 $MBD_DIR/$LIBDIR/
+
+    install -m 644 $IMGPATH/etc/udev/udev.conf $MBD_DIR/etc/udev/udev.conf
+    for i in $IMGPATH/lib/udev/rules.d/*.rules ; do
+       install -m 644 $i $MBD_DIR/lib/udev/rules.d/${i##*/}
+    done
+    for i in $IMGPATH/etc/udev/rules.d/*.rules ; do
+       install -m 644 $i $MBD_DIR/etc/udev/rules.d/${i##*/}
+    done
+    for i in $IMGPATH/lib/udev/*; do
+       if [ -f $i ]; then install -m 755 $i $MBD_DIR/lib/udev/${i##*/}; fi
+    done
+    rm -f $MBD_DIR/lib/udev/rules.d/*persistent*
+    rm -f $MBD_DIR/lib/udev/rules.d/*generator*
+
+    install -m 644 $LOADERBINDIR/$MYLOADERTR $MBD_DIR/etc/loader.tr
+    for i in a/ansi d/dumb l/linux s/screen v/vt100 v/vt100-nav v/vt102 x/xterm x/xterm-color g/gnome ; do
+        [ -f $IMGPATH/usr/share/terminfo/$i ] && \
+        install -m 644 $IMGPATH/usr/share/terminfo/$i $MBD_DIR/etc/terminfo/$i
+    done
+
+    makeproductfile $MBD_DIR
+
+    for n in insmod rmmod modprobe; do
+        instbin $IMGPATH /usr/sbin/$n $MBD_DIR /sbin/$n
+    done
+
+    ln -s /sbin/init $MBD_DIR/init
+    ln -s /proc/mounts $MBD_DIR/etc/mtab
+    ln -s sbin $MBD_DIR/bin
+    mkdir -p $MBD_DIR/var/lib
+    ln -s ../../tmp $MBD_DIR/var/lib/xkb
+
+    # s390/s390x need sshd setup
+    if [ "$BUILDARCH" = "s390" -o "$BUILDARCH" = "s390x" ]; then
+        setupShellEnvironment
+    fi
+
+cat > $MBD_DIR/.profile <<EOF
+PATH=/bin:/usr/bin:/usr/sbin:/mnt/sysimage/sbin:/mnt/sysimage/usr/sbin:/mnt/sysimage/bin:/mnt/sysimage/usr/bin
+export PATH
+EOF
+
+    rm -f $MBD_FSIMAGE
+    (cd $MBD_DIR; find . |cpio --quiet -c -o) |gzip -9 > $MBD_FSIMAGE
+
+    size=$(du $MBD_FSIMAGE | awk '{ print $1 }')
+
+    echo "Wrote $MBD_FSIMAGE (${size}k compressed)"
+
+    if [ -n "$EXTRAINITRDPATH" ]; then
+        mkdir -p `dirname $EXTRAINITRDPATH`
+        cp -a $MBD_FSIMAGE $EXTRAINITRDPATH
+    fi
+
+    if [ -z "$KEEP" ]; then
+        rm -rf $MBD_FSIMAGE $MBD_BOOTTREE
+    fi
+}
+
+makeinstimage () {
+    imagename=$1
+    type=$2
+    tmp=$TMPDIR/instimage.dir.$$
+
+    rm -rf $tmpimage $tmp
+    mkdir -p $mntpoint $tmp
+
+    mkdir -p $tmp
+    (cd $IMGPATH; find . | cpio --quiet -p $tmp)
+    makeproductfile $tmp
+
+    if [ -z "$type" -o "$type" = "cramfs" ]; then
+        echo "Running mkcramfs $CRAMBS $tmp $INSTIMGPATH/${imagename}2.img"
+        mkfs.cramfs $CRAMBS $tmp $TMPDIR/${imagename}2.img.$$
+    elif [ "$type" = "squashfs" ]; then
+        echo "Running mksquashfs $tmp $TMPDIR/${imagename}2.img -all-root -no-fragments -no-progress"
+        mksquashfs $tmp $TMPDIR/${imagename}2.img.$$ -all-root -no-fragments -no-progress
+        chmod 0644 $TMPDIR/${imagename}2.img.$$
+    fi
+    cp $TMPDIR/${imagename}2.img.$$ $INSTIMGPATH/${imagename}2.img
+    size=$(ls -l $INSTIMGPATH/${imagename}2.img | awk '{print $5}')
+    size=$(expr $size / 1024)
+    echo "Wrote $INSTIMGPATH/${imagename}2.img (${size}k)..."
+    relpath=${INSTIMGPATH#$TOPDESTPATH/}
+    echo "instimage = ${relpath}/${imagename}2.img" >> $TOPDESTPATH/.treeinfo
+    rm -rf $tmp
+}
+
+makemainimage () {
+    imagename=$1
+    type=$2
+    mmi_tmpimage=$TMPDIR/instimage.img.$$
+    mmi_mntpoint=$TMPDIR/instimage.mnt.$$
+
+    rm -rf $mmi_tmpimage $mmi_mntpoint
+    mkdir $mmi_mntpoint
+
+    if [ $type = "ext2" ]; then
+        SIZE=$(du -sk $IMGPATH | awk '{ print int($1 * 1.1) }')
+        if [ -d $IMGPATH/usr/lib/anaconda-runtime ]; then
+            ERROR=$(du -sk $IMGPATH/usr/lib/anaconda-runtime | awk '{ print $1 }')
+            SIZE=$(expr $SIZE - $ERROR)
+        fi
+        if [ -d $IMGPATH/usr/share/syslinux ]; then
+            ERROR=$(du -sk $IMGPATH/usr/share/syslinux | awk '{ print $1 }')
+            SIZE=$(expr $SIZE - $ERROR)
+        fi
+        dd if=/dev/zero bs=1k count=${SIZE} of=$mmi_tmpimage 2>/dev/null
+        mke2fs -q -F $mmi_tmpimage > /dev/null
+        tune2fs -c0 -i0 $mmi_tmpimage >/dev/null
+        mount -o loop $mmi_tmpimage $mmi_mntpoint
+
+        (cd $IMGPATH; find . |
+            fgrep -v "./usr/lib/anaconda-runtime" |
+            fgrep -v "./usr/share/syslinux"
+            cpio -H crc -o) | (cd $mmi_mntpoint; cpio -iumd)
+        makeproductfile $mmi_mntpoint
+        umount $mmi_mntpoint
+        rmdir $mmi_mntpoint
+    elif [ $type = "squashfs" ]; then
+        makeproductfile $IMGPATH
+        echo "Running mksquashfs $IMGPATH $mmi_tmpimage -all-root -no-fragments -no-progress"
+        mksquashfs $IMGPATH $mmi_tmpimage -all-root -no-fragments -no-progress
+        chmod 0644 $mmi_tmpimage
+        SIZE=$(expr `cat $mmi_tmpimage | wc -c` / 1024)
+    elif [ $type = "cramfs" ]; then
+        makeproductfile $IMGPATH
+        echo "Running mkcramfs $CRAMBS $IMGPATH $mmi_tmpimage"
+        mkfs.cramfs $CRAMBS $IMGPATH $mmi_tmpimage
+        SIZE=$(expr `cat $mmi_tmpimage | wc -c` / 1024)
+    fi
+
+    cp $mmi_tmpimage $INSTIMGPATH/${imagename}.img
+    chmod 644 $INSTIMGPATH/${imagename}.img
+
+    echo "Wrote $INSTIMGPATH/${imagename}.img (${SIZE}k)"
+    relpath=${INSTIMGPATH#$TOPDESTPATH/}
+    echo "mainimage = ${relpath}/${imagename}.img" >> $TOPDESTPATH/.treeinfo
+
+    rm $mmi_tmpimage
+}
+
+makeSecondStage() {
+    echo "[stage2]" >> $TOPDESTPATH/.treeinfo
+    echo "Building install.img"
+    makemainimage "install" "squashfs"
+    [ $? = 0 ] || exit 1
+}
+
+doPostImages() {
+   /bin/true
+}
+
+# this gets overloaded if we're on an EFI-capable arch (... with grub)
+makeEfiImages()
+{
+    /bin/true
+}
+
+# source the architecture specific mk-images file so we can call functions
+# in it
+if [ ${BUILDARCH} = s390x ]; then
+    # FIXME: this is a bad hack for s390, but better than copying for now
+    source $TOPDIR/mk-images.s390
+elif [ ${BUILDARCH} = ppc64 ]; then
+    # ... and similar for ppc64
+    source $TOPDIR/mk-images.ppc
+elif [ ${BUILDARCH} = "x86_64" -o ${BUILDARCH} = "i386" ]; then
+    source $TOPDIR/mk-images.x86
+    source $TOPDIR/mk-images.efi
+else
+    source $TOPDIR/mk-images.${BUILDARCH}
+fi
+
+# Find the kernel, unpack it, and verify it
+kerneltags="kernel"
+efiarch=""
+arches="$BUILDARCH"
+if [ "$BUILDARCH" = "ppc" ]; then
+    arches="ppc64 ppc"
+elif [ "$BUILDARCH" = "i386" ]; then
+    arches="i586"
+    efiarch="ia32"
+    kerneltags="kernel kernel-PAE"
+    kernelxen="kernel-PAE"
+elif [ "$BUILDARCH" = "x86_64" ]; then
+    kerneltags="kernel"
+    efiarch="x64"
+elif [ "$BUILDARCH" = "ia64" ]; then
+    kerneltags="kernel"
+    efiarch="ia64"
+fi
+
+foundakernel=""
+for KERNELARCH in $arches; do
+    for kernelvers in $kerneltags; do
+        kpackage=$(findPackage $kernelvers)
+        if [ "$KERNELARCH" = "i586" -a -z "$kpackage" ]; then
+            echo "No i586 kernel, trying i686..."
+            KERNELARCH="i686"
+            kpackage=$(findPackage $kernelvers)
+        fi
+
+        if [ -z "$kpackage" ]; then
+            echo "Unable to find kernel package $kernelvers"
+            continue
+        fi
+
+        yumdownloader -c $yumconf --archlist=$KERNELARCH $kpackage
+        kpackage="$kpackage.rpm"
+        if [ ! -f "$kpackage" ]; then
+            echo "kernel ($kernelvers) doesn't exist for $KERNELARCH.  skipping"
+            continue
+        fi
+
+        KERNELROOT=$KERNELBASE/$KERNELARCH
+        mkdir -p $KERNELROOT
+
+        foundakernel="yes"
+
+        if [ "$BUILDARCH" = "ia64" ]; then
+            vmlinuz=$(rpm --nodigest --nosignature -qpl $kpackage |grep ^/boot/efi/EFI/redhat/vmlinuz | head -n 1)
+            version=${vmlinuz##/boot/efi/EFI/redhat/vmlinuz-}
+        else
+            vmlinuz=$(rpm --nodigest --nosignature -qpl $kpackage |grep ^/boot/vmlinuz | head -n 1)
+            version=${vmlinuz##/boot/vmlinuz-}
+        fi
+        arch=$(rpm --nodigest --nosignature --qf '%{ARCH}\n' -qp $kpackage)
+
+        rpm2cpio $kpackage | (cd $KERNELROOT; cpio --quiet -iumd)
+        rm -f $kpackage
+        # expand out any available firmware too
+        for p in $(repoquery -c $yumconf '*firmware*') ; do
+            yumdownloader -c $yumconf $p
+            rpm2cpio *firmware*.rpm | (cd $KERNELROOT; cpio --quiet -iumd)
+            rm -f *firmware*.rpm
+        done
+
+        if [ ! -d "$KERNELROOT/lib/modules/$version" ]; then
+            echo "$KERNELROOT/lib/modules/$version is not a valid modules directory" 2>&1
+            exit 1
+        fi
+
+        if [ ! -f "$KERNELROOT/$KERNELDIR/${KERNELNAME}-$version" ]; then
+            echo "$KERNELROOT/$KERNELDIR/${KERNELNAME}-$version does not exist"
+            exit 1
+        fi
+
+        allmods=$(find $KERNELROOT/lib/modules/$version -name *.ko)
+
+        rundepmod $KERNELROOT
+        $GENMODINFO $KERNELROOT/lib/modules/$version > $MODINFO
+
+        # make the boot images
+        makeBootImages
+
+        makeEfiImages $yumconf
+    done
+done
+
+if [ -n "$foundakernel" ]; then
+    makeSecondStage
+    rm -rf $KERNELBASE
+fi
+
+doPostImages
+
+cd $TOPDIR
diff -ruN anaconda-11.5.0.42.orig/scripts/mk-images.x86 anaconda-11.5.0.42/scripts/mk-images.x86
--- anaconda-11.5.0.42.orig/scripts/mk-images.x86	2009-04-09 16:53:01.000000000 -0400
+++ anaconda-11.5.0.42/scripts/mk-images.x86	2009-04-09 17:00:45.000000000 -0400
@@ -159,15 +159,16 @@
     if [ -n "$BOOTISO" ]; then
         EFIARGS=""
         EFIGRAFT=""
-        if [ -f $TOPDESTPATH/images/pxeboot/efiboot.img ]; then
-            cp $TOPDESTPATH/images/pxeboot/efiboot.img $TOPDESTPATH/isolinux/efiboot.img
-            EFIARGS="-eltorito-alt-boot -e isolinux/efiboot.img -no-emul-boot"
-            EFIGRAFT="EFI/boot=$TOPDESTPATH/EFI/boot"
+        if [ -f $TOPDESTPATH/images/efiboot.img ]; then
+            echo "Found efiboot.img, making an EFI-capable boot.iso"
+            EFIARGS="-eltorito-alt-boot -e images/efiboot.img -no-emul-boot"
+            EFIGRAFT="EFI/BOOT=$TOPDESTPATH/EFI/BOOT"
+        else
+            echo "No efiboot.img found, making BIOS-only boot.iso"
         fi
         BIOSARGS="-b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table"
-        echo $PWD:\$ mkisofs -o $TOPDESTPATH/images/$BOOTISO $BIOSARGS $EFIARGS -R -J -V "$PRODUCT" -T -graft-points isolinux=$TOPDESTPATH/isolinux images/install.img=$TOPDESTPATH/images/install.img $EFIGRAFT
-        mkisofs -o $TOPDESTPATH/images/$BOOTISO $BIOSARGS $EFIARGS -R -J -V "$PRODUCT" -T -graft-points isolinux=$TOPDESTPATH/isolinux images/install.img=$TOPDESTPATH/images/install.img $EFIGRAFT
-        implantisomd5 $TOPDESTPATH/images/$BOOTISO
+        mkisocmd="mkisofs -v -o $TOPDESTPATH/images/$BOOTISO $BIOSARGS $EFIARGS -R -J -V "$PRODUCT" -T -graft-points isolinux=$TOPDESTPATH/isolinux images=$TOPDESTPATH/images $EFIGRAFT"
+        echo $PWD:\$ $mkisocmd
+	$mkisocmd
     fi
-
 }
